require "main/varibles"
local TAG = "game.gui_script: "

local score = 0
local planets_count = 0
local CAMERA_ID = hash("/camera")

local random = require "main/random"
local monarch = require "monarch.monarch"
local transitions = require "monarch.transitions.gui"
local gooey = require "gooey.gooey"

local boost = false
local boost_clicks = 0

local autopilot = false
local autopilot_score = 0 --varible for counting time for increasing score
local autopilot_time = 0 --varible for counting duration of autopilot 
local autopilot_duration = 5 --control time varible for autopilot

local first_click = false
local tap_timer = nil

local function shake_score(self)
	local node = gui.get_node("score")
	local position = gui.get_position(node)

	local new_x = random.random(-5, 5)
	local new_y = random.random(-5, 5)

	position.x = position.x + new_x
	position.y = position.y + new_y

	gui.animate(node, "position", position, gui.EASING_LINEAR, 0.1)
end

function pause_pressed(button)
	print(TAG, "pause_pressed")
	msg.post("game:/rocket#rocket", "pause")
	monarch.show("pause_screen")
end

function pause_update(button)
	if button.pressed_now then
		gui.play_flipbook(button.node, hash("blue_button02"))
	elseif button.released_now then
		gui.play_flipbook(button.node, hash("blue_button04"))
	elseif not button.pressed and button.over_now then
		gui.play_flipbook(button.node, hash("blue_button02"))
	elseif not button.pressed and button.out_now then
		gui.play_flipbook(button.node, hash("blue_button04"))
	end
end

function boost_pressed(button)
	if BOOST_COUNT >= 1 then
		msg.post("game:/bonus_driver#bonus_driver", "boost", {planets_count})
		boost = true
	end
end
function boost_update(button)
	if BOOST_COUNT >= 1 then
		if button.pressed_now then
			gui.play_flipbook(button.node, hash("blue_button02"))
		elseif button.released_now then
			gui.play_flipbook(button.node, hash("blue_button04"))
		elseif not button.pressed and button.over_now then
			gui.play_flipbook(button.node, hash("blue_button02"))
		elseif not button.pressed and button.out_now then
			gui.play_flipbook(button.node, hash("blue_button04"))
		end
	else
		gui.set_color(button.node, vmath.vector4(1,1,1,.2))
	end
end
function autopilot_pressed(button)
	if AUTOPILOT_COUNT >= 1 and not autopilot then
		msg.post("game:/bonus_driver#bonus_driver", "autopilot")
		autopilot = true
	end
end
function autopilot_update(button)
	if AUTOPILOT_COUNT >= 1 then
		if button.pressed_now then
			gui.play_flipbook(button.node, hash("blue_button02"))
		elseif button.released_now then
			gui.play_flipbook(button.node, hash("blue_button04"))
		elseif not button.pressed and button.over_now then
			gui.play_flipbook(button.node, hash("blue_button02"))
		elseif not button.pressed and button.out_now then
			gui.play_flipbook(button.node, hash("blue_button04"))
		end
	else
		gui.set_color(button.node, vmath.vector4(1,1,1,.2))
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	math.randomseed(os.clock()*100000000000)

	self.transition = transitions.create(gui.get_node("score"))
	.show_in(transitions.scale_in, gui.EASING_OUTQUAD, 0.6, 0)
	.show_out(transitions.scale_out, gui.EASING_INQUAD, 0.66, 0)
	.back_in(transitions.slide_in_left, gui.EASING_OUTQUAD, 0.66, 0)
	.back_out(transitions.slide_out_right, gui.EASING_INQUAD, 0.6, 0)

	self.transition1 = transitions.create(gui.get_node("boost/bg"))
	.show_in(transitions.scale_in, gui.EASING_OUTQUAD, 0.6, 0)
	.show_out(transitions.slide_out_right, gui.EASING_INQUAD, 0.6, 0)
	.back_in(transitions.slide_in_left, gui.EASING_OUTQUAD, 0.6, 0)
	.back_out(transitions.slide_out_right, gui.EASING_INQUAD, 0.6, 0)

	self.transition2 = transitions.create(gui.get_node("autopilot/bg"))
	.show_in(transitions.scale_in, gui.EASING_OUTQUAD, 0.6, 0)
	.show_out(transitions.slide_out_right, gui.EASING_INQUAD, 0.6, 0)
	.back_in(transitions.slide_in_left, gui.EASING_OUTQUAD, 0.6, 0)
	.back_out(transitions.slide_out_right, gui.EASING_INQUAD, 0.6, 0)

	self.transition3 = transitions.create(gui.get_node("pause/bg"))
	.show_in(transitions.scale_in, gui.EASING_OUTQUAD, 0.6, 0)
	.show_out(transitions.slide_out_right, gui.EASING_INQUAD, 0.6, 0)
	.back_in(transitions.slide_in_left, gui.EASING_OUTQUAD, 0.6, 0)
	.back_out(transitions.slide_out_right, gui.EASING_INQUAD, 0.6, 0)

	self.transition4 = transitions.create(gui.get_node("tap"))
	.show_in(transitions.scale_in, gui.EASING_OUTQUAD, 0.6, 0)
	.show_out(transitions.slide_out_right, gui.EASING_INQUAD, 0.6, 0)
	.back_in(transitions.slide_in_left, gui.EASING_OUTQUAD, 0.6, 0)
	.back_out(transitions.slide_out_right, gui.EASING_INQUAD, 0.6, 0)

	local timer_flag = false
	tap_timer = timer.delay(.5, true, function(self, handle, time_elapsed)
		local node = gui.get_node("tap")
		local color = vmath.vector4(random.random(1, 10) / 10, 
		random.random(1, 10) / 10, 
		random.random(1, 10) / 10, 
		1)
		gui.animate(node, "color", color, gui.EASING_LINEAR, .5)
		if not timer_flag then
			gui.animate(node, "scale", 1.2, gui.EASING_OUTINELASTIC, .5)
			gui.animate(node, "rotation", vmath.vector3(0, 0, random.random(0, 30)), gui.EASING_LINEAR, .5)
			timer_flag = true
		else
			gui.animate(node, "scale", .5, gui.EASING_OUTINELASTIC, .5)
			gui.animate(node, "rotation", vmath.vector3(0, 0, -random.random(0, 30)), gui.EASING_LINEAR, .5)
			timer_flag = false
		end
	end)
end

function update(self, dt)
	if autopilot and autopilot_time <= autopilot_duration then
		local node = gui.get_node("score")
		gui.set_text(node, score)
		autopilot_time = autopilot_time + dt
		autopilot_score = autopilot_score + dt
		if autopilot_score >= 0.2 then
			score = score + 1
			autopilot_score = 0
			particlefx.play("/rocket#rocket_egine")
		end
	elseif autopilot_time > autopilot_duration then
		msg.post("game:/bonus_driver#bonus_driver", "autopilot_end")
		autopilot_time = 0
		autopilot_score = 0
	end
end

function on_message(self, message_id, message, sender)
	self.transition.handle(message_id, message, sender)
	self.transition1.handle(message_id, message, sender)
	self.transition2.handle(message_id, message, sender)
	self.transition3.handle(message_id, message, sender)
	self.transition4.handle(message_id, message, sender)

	
	if message_id == monarch.TRANSITION.DONE and message.transition == monarch.TRANSITION.SHOW_IN then
		print("Show in done!")
	end

	if message_id == hash("increase_planets_count") then
		planets_count = planets_count + 1 
	end

	if message_id == hash("set_boost") then
		boost = message[1]
	end

	if message_id == hash("set_autopilot") then
		autopilot = message[1]
	end

	if message_id == hash("lose") then
		if SECOND_LIFE_COUNT == 0 then
			MONEY = MONEY + score * (1 + MONEY_PER_CLICK_COUNT)
			if score > BEST_SCORE then
				BEST_SCORE = score
			end
			monarch.back()
		else
			print(TAG, "second life")
			monarch.show("second_life_screen")
		end
	end
end

function on_input(self, action_id, action)
	gooey.button("boost/bg", action_id, action, boost_pressed, boost_update)
	gooey.button("autopilot/bg", action_id, action, autopilot_pressed, autopilot_update)
	gooey.button("pause/bg", action_id, action, pause_pressed, pause_update)
	
	if action_id == hash("touch") and action.pressed then

		if not first_click then
			first_click = true
			local node = gui.get_node("tap")
			gui.animate(node, "position", vmath.vector3(320,-500,0), gui.EASING_INOUTELASTIC, 1, 0,
			function(self, node)
				timer.cancel(tap_timer) 
				gui.set_enabled(node, false)
			end)
		end

		--updating score text
		score = score + 1
		local node = gui.get_node("score")
		gui.set_text(node, score)

		if boost and boost_clicks < 10 then
			msg.post(CAMERA_ID, "shake", { intensity = 0.1, duration = 0.5, direction = hash("both") })
			boost_clicks = boost_clicks + 1
		else
			if boost_clicks > 0 then
				msg.post("game:/bonus_driver#bonus_driver", "boost_end")
				boost_clicks = 0
			end
			msg.post(CAMERA_ID, "shake", { intensity = 0.01, duration = 0.5, direction = hash("both") })
		end
		shake_score(self)

		--TODO: made with 50
		if score == 30 then
			msg.post("game:/bonus_driver#bonus_driver", "boost", {planets_count})
		end

		if score == 40 then
			msg.post("game:/bonus_driver#bonus_driver", "boost_end")
		end
	end
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
